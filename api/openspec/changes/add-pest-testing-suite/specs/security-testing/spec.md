# Specification: Security Testing

## ADDED Requirements

### Requirement: JWT Signature Validation Tests
JWT tokens with invalid signatures SHALL be rejected to prevent token tampering attacks.

#### Scenario: Reject JWT with tampered signature
- GIVEN valid JWT token
- WHEN signature portion is modified (last part after second dot)
- AND GET /api/v1/me with tampered JWT
- THEN response status is 401
- AND JSON message contains "Invalid JWT Token"

#### Scenario: Reject JWT with invalid algorithm
- GIVEN JWT with header `{"typ": "JWT", "alg": "none"}`
- WHEN GET /api/v1/me with that JWT
- THEN response status is 401
- AND token is rejected (algorithm "none" not allowed)

#### Scenario: Reject JWT signed with wrong key
- GIVEN JWT signed with different RSA private key (not config/jwt/private.pem)
- WHEN GET /api/v1/me with that JWT
- THEN response status is 401
- AND verification fails due to signature mismatch

#### Scenario: Accept JWT with valid signature
- GIVEN JWT generated by JWTTokenManagerInterface with correct RS256 signature
- WHEN GET /api/v1/me with that JWT
- THEN response status is 200
- AND user profile is returned

### Requirement: JWT Expiration Tests
Expired JWT tokens SHALL be rejected to enforce token time-to-live security.

#### Scenario: Reject expired JWT
- GIVEN JWT with `exp` claim set to 2 hours ago
- WHEN GET /api/v1/me with expired JWT
- THEN response status is 401
- AND JSON message contains "Expired JWT Token"

#### Scenario: Accept JWT within TTL
- GIVEN JWT with `exp` claim set to 30 minutes from now
- WHEN GET /api/v1/me with valid JWT
- THEN response status is 200
- AND request is authenticated successfully

### Requirement: Refresh Token Security Tests
Refresh tokens SHALL be validated and protected against reuse attacks.

#### Scenario: Refresh token cannot be reused after logout
- GIVEN valid refresh_token
- WHEN POST /api/v1/auth/logout with that token
- AND POST /api/v1/auth/refresh with same token
- THEN refresh request returns 401
- AND error is "invalid_token"

#### Scenario: Expired refresh tokens are rejected
- GIVEN refresh_token with TTL expired (created 31 days ago)
- WHEN POST /api/v1/auth/refresh with expired token
- THEN response status is 401
- AND error is "invalid_token" or "Refresh token invalide ou expir√©"

#### Scenario: Refresh tokens are tied to specific user
- GIVEN refresh_token for user A
- WHEN POST /api/v1/auth/refresh with that token
- AND new access_token is decoded
- THEN JWT username claim = user A email
- AND JWT does NOT contain user B data

### Requirement: Google OAuth CSRF Protection Tests
OAuth flow SHALL validate state parameter to prevent CSRF attacks.

#### Scenario: Reject callback with invalid state
- GIVEN OAuth connect initiated with state='abc123'
- WHEN GET /api/v1/auth/google/callback?code=xxx&state=wrong-state
- THEN redirect to frontend with error=authentication_failed
- AND OAuth flow is aborted (user not authenticated)

#### Scenario: Accept callback with valid state
- GIVEN OAuth connect initiated with state='valid-state'
- AND state is stored in session/cache
- WHEN GET /api/v1/auth/google/callback?code=xxx&state=valid-state
- THEN state is validated successfully
- AND OAuth flow continues to user provisioning

### Requirement: Google ID Collision Protection Tests
System SHALL prevent Google ID hijacking by detecting mismatched Google IDs for same email.

#### Scenario: Prevent linking different Google ID to existing account
- GIVEN existing User with email='alice@example.com', googleId='111'
- WHEN GoogleUserProvisioner.provisionUser('222', 'alice@example.com', ...) is called (different Google ID)
- THEN ConflictException is thrown with status 409
- AND User googleId remains '111' (not changed to '222')

#### Scenario: Allow updating tokens for same Google ID
- GIVEN existing User with email='alice@example.com', googleId='111'
- WHEN GoogleUserProvisioner.provisionUser('111', 'alice@example.com', ...) is called (same Google ID)
- THEN User tokens are updated
- AND no exception is thrown

### Requirement: Authorization Tests
Users SHALL only access their own resources, admins have elevated privileges.

#### Scenario: Users can only access own profile
- GIVEN JWT for user A (id=1, email='usera@test.com')
- WHEN GET /api/v1/me with user A JWT
- THEN returns user A data (id=1)
- AND does NOT return user B data

#### Scenario: Admin can delete users (ROLE_ADMIN)
- GIVEN User with roles=['ROLE_ADMIN']
- WHEN DELETE /api/v1/users/{id} with admin JWT
- THEN response status is 204 or 200 (success)
- AND user is deleted from database

#### Scenario: Regular user cannot delete users
- GIVEN User with roles=['ROLE_USER'] only
- WHEN DELETE /api/v1/users/{id} with regular user JWT
- THEN response status is 403 (Forbidden)
- AND user is NOT deleted

### Requirement: Password Hashing Security Tests
User passwords SHALL be hashed with bcrypt and proper cost factor.

#### Scenario: Passwords are hashed with bcrypt
- WHEN User is created with password "plaintext"
- THEN user.password in database starts with "$2y$"
- AND password length is ~60 characters
- AND password does NOT equal "plaintext"

#### Scenario: Password hashes are not reversible
- GIVEN User with hashed password
- WHEN password hash is retrieved from database
- THEN hash cannot be reversed to plaintext (one-way function)
- AND hash must be verified with isPasswordValid()

#### Scenario: Same password produces different hashes (salt)
- WHEN two Users are created with same password "secret123"
- THEN user1.password !== user2.password (different salts)
- AND both hashes verify correctly with isPasswordValid()
